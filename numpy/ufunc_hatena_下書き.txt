#hatena ufunc

今回は、numpyの備忘録としてuniversal function(通称ufunc)について整理しておきたいと思います。

ufuncとは、何ぞや
universal functionとは、numpy配列の要素ごとに何か関数を適応して、numpy配列を返す関数のことをいいます。

ufuncのいいところ
　内部でC言語を使っているので、早い
　非常に多くのメソッドが用意されている→for文とかで頑張らなくていい

>|python|
#coding:utf-8
import numpy as np

a = np.arange(8)
result : array([0, 1, 2, 3, 4, 5, 6, 7])
||<

例として、ufunc.square()を使ってみたいと思います。
この関数は各要素を自乗した配列を返してくれる関数です。
下の結果を見て頂くと、各要素、自乗されていることがわかると思います。
>|python|
np.square(a)
result : array([ 0,  1,  4,  9, 16, 25, 36, 49])
||<

このように、ndarray一つを引数にとる関数は他にもいくつかあります。
<table border="3">
<tr>
<td>関数</td>
<td>内容</td>
</tr>
<tr>
<td>abs</td>
<td>整数、小数、複素数の絶対値を要素ごとに戻す</td>
</tr>
<tr>
<td>sqrt</td>
<td>平方根を要素ごとに戻す</td>
</tr>
<tr>
<td>exp</td>
<td>自然対数の底eのべき乗を要素ごとに戻す</td>
</tr>
<tr>
<td>isnan</td>
<td>要素ごとにNaN判定を行い、真偽結果をTrue or Falseで返す</td>
</tr>
<tr>
<td>sign</td>
<td>要素ごとの符号を返す。(正=1,負=-1,0=0)</td>
</tr>
</table>
これは関数のほんの一例ですので、詳しくは以下ドキュメントを参考にしてみてください。
https://docs.scipy.org/doc/numpy/reference/ufuncs.html


さて、上の例では、一つのndarrayを引数に取りましたが、
2つのndarrayを引数に取る関数も存在します。
試しにufunc.addを使ってみたいと思います。
>|python|
a = np.arange(8)
result : array([0, 1, 2, 3, 4, 5, 6, 7])
np.add(a,a)
result : array([ 0,  2,  4,  6,  8, 10, 12, 14])
||<
結果を見て頂くと、2つのndarrayの各要素同士の和が返されていることがわかります。
このように2つのndarrayを引数とする関数も多く用意されており、
以下一例ですが、加減乗除はもちろん、2つの要素を比較して最大値、最小値を返す関数もあります。
<table border="3">
<tr>
<td>関数</td>
<td>内容</td>
</tr>
<tr>
<td>add</td>
<td>対応する要素同士の和を返す</td>
</tr>
<tr>
<td>subtract</td>
<td>subtract(1,2)だとしたら、1の配列から2の配列の対応する要素の差を取る</td>
</tr>
<tr>
<td>multiply</td>
<td>各要素の積を返す</td>
</tr>
<tr>
<td>divide</td>
<td>divide(1,2)としたら、1の配列要素を2の対応する配列要素で割る</td>
</tr>
<tr>
<td>maximum</td>
<td>対応する要素同士の最大値を返す</td>
</tr>
<tr>
<td>minimum</td>
<td>対応する要素同士の最小値を返す</td>
</tr>
</table>

###ここから
>|python|
ta = np.array([[2,4,3],[3,5,7],[2,8,4]])
tb = np.array([[3,2,3],[1,1,1],[6,6,6]])
ta.shape
result : (3, 3)

np.add(ta,tb)
result : array([[ 5,  6,  6],[ 4,  6,  8],[ 8, 14, 10]])
||<
(3×3)の配列を2つ作って、試しに足し算を行ってみます。
返された配列は(3×3)の配列で、ta(1,1)とtb(1,1)の要素,ta(1,2)とtb(1,2)の要素・・・というように
もちろん同じ対応する要素同士の計算になってますね。


<h2>少し応用</h2>
少し使い方がややこしいですが、便利な関数についての紹介。
<h3>reduce</h3>
reduce：演算を連続的に適応する。
はい、何を言っているか分かりませんので、実例を見ていきましょう。
まずは(2×3×2)の3次元配列を用意。
どこの要素が計算されてるかわかりやすいように、配列の要素は1~12を順番に入れています。
>|python|
ta = np.array([
               [[1,2],[3,4],[5,6]],
               [[7,8],[9,10],[11,12]]
               ])
ta.shape
result : (2,3,2)
||<
reduceに入る前に、(2×3×2)の形のイメージが付きづらいかもしれませんが、まずは、ta=np.array([])を見て頂いて、
まず一番外側の[]の中に何個の配列要素があるか数えると[[1,2],[3,4],[5,6]]と[[7,8],[9,10],[11,12]]の２個ある
あることがわかります。これが(2×3×2)でいう一番左側の2を指しています。
次の[]の中身に何個要素が入っているか見ると、[[1,2],[3,4],[5,6]]なので[1,2],[3,4],[5,6]の3つ入ってることがわかります。これが、shape(2×3×2)の3の部分に当ります。
最後の[]の中身を確認すると[1,2]なので2つですね。
このあたりはたまに混乱するので、一度確認してみるとスッキリすると思います。（ta[1,:]などで具体的にどこの部分を指しているか✓するのも良し）

さて、実際にreduceを使った例をあげていきます。
>|python|
#1次元配列の場合
a = np.arange(8)
np.add.reduce(a)
result : 28

#3次元配列の場合
ta = np.array([
               [[1,2],[3,4],[5,6]],
               [[7,8],[9,10],[11,12]]
               ])

np.add.reduce(ta, axis=0)
result : array([[ 8(1+7), 10(2+8)],
       [12(3+9), 14(4+10)],
       [16(5+11), 18(6+12)]])

||<
1次元配列の場合は、単純に配列内の要素を全て足し合わせた結果が戻ってきます。
3次元配列の場合は、axisで指定した軸方向に対して足し算を行います。
axisもよくわからなくなりますが、axisは、shapeのインデックスを指定しており、
axis=0ならshape(2×3×2)の一番左側(index=0)を指定、axis=1ならshape(2×3×2)の3(index=1)を指定していることになります。

先程の復讐ですが、shape(2×3×2)の一番左の2が指してる部分は、[[1,2],[3,4],[5,6]]と[[7,8],[9,10],[11,12]]の部分でした。
つまり、axis=0で、この２つの配列の各要素を足し合わせることを指定していることになります。

axis=1,2もやってみると以下のようになります。
>|python|
ta = np.array([
               [[1,2],[3,4],[5,6]],
               [[7,8],[9,10],[11,12]]
               ])

np.add.reduce(ta, axis=1)
result : array([[ 9(1+3+5), 12(2+4+6)],
       [27(7+9+11), 30(8+10+12)]])

np.add.reduce(ta, axis=2)
result : array([[ 3(1+2),  7(3+4), 11(5+6)],
       [15(7+8), 19(9+10), 23(11+12)]])
||<
（）内の数字が各配列の要素の値になっているので、照らし合わせてどういう軸方向で計算されてるか確認してみてください。

<h3>accumulate</h3>
accumulate：途中の計算過程を含めた配列を戻す。
言葉だけだとよくわからないので、実際に動かしてみます。
>|python|
tb = np.array([[3,2,3],[1,1,1],[6,6,6]])
tb.shape
result : (3,3)

tb.add.accumulate(tb, axis=1)
result : array([[ 3,  5,  8],
       [ 1,  2,  3],
       [ 6, 12, 18]])
#reduceの場合、足し算の結果だけ配列として戻る
tb.add.reduce(tb, axis=1)
result : array([ 8,  3, 18])
||<

axis = 1指定なので [3,2,3]の足し算(=8)、[1,1,1]の足し算(=3)、[6,6,6]の足し算(=18)になります。
（add.reduceの結果からも処理内容が確認できます）
accumulateは足し算の過程（累積値）の結果を返すので、例えば[3,2,3]であれば[3, 3+2(=5), 3+2+3(=8)]のような配列を返すことになります。

<h3>outer</h3>
outer(a,b) : a,b全ての要素の組み合わせに対して、関数を適用する(add, subtractなど)
こちらも早速例を見ていきましょう。
先ほどと同様に、どの要素が計算に使われているか分かりやすいように、1~4までが入った(2×2)の配列と5~8までが入った(2×2)の配列を使います。
>|python|
a = np.array([[1,2],[3,4]])
b = np.array([[5,6],[7,8]])
np.add.outer(a,b)
result : array([[[[ 6(1+5),  7(1+6)],
         [ 8(1+7),  9(1+8)]],

        [[ 7(2+5),  8(2+6)],
         [ 9(2+7), 10(2+8)]]],


       [[[ 8(3+5),  9(3+6)],
         [10(3+7), 11(3+8)]],

        [[ 9(4+5), 10(4+6)],
         [11(4+7), 12(4+8)]]]])
||<
各要素の組み合わせ全てに対しての足し算結果が配列として戻ってきていることがわかります。
返ってきた配列の形は(2,2,2,2)となっており、a.shape + b.shapeの形になっていることに注意してください。

<h2>終わりに</h2>
私自身、ufuncをこれまであまり使っては来ませんでしたが、きっとどこかで使う機会が来るだろう(たぶん)、、、ということで、
今回備忘録としてまとめてみました。
